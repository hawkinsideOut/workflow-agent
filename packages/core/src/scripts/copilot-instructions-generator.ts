/**
 * Copilot Instructions Generator
 *
 * Generates .github/copilot-instructions.md from the project's guidelines directory.
 * This file serves as the Single Source of Truth for AI agents (GitHub Copilot, Claude, etc.)
 * when working on the codebase.
 *
 * Features:
 * - Reads all markdown files from guidelines/
 * - Extracts key rules and summaries from each guideline
 * - Loads project config from workflow.config.json
 * - Preserves custom user content between markers
 * - Provides links to full guideline documents
 */

import { readFileSync, writeFileSync, existsSync, readdirSync, mkdirSync } from "fs";
import { join, basename } from "path";

// Markers for custom user content that should be preserved on regeneration
const CUSTOM_START_MARKER = "<!-- CUSTOM START -->";
const CUSTOM_END_MARKER = "<!-- CUSTOM END -->";
const GENERATED_MARKER = "<!-- AUTO-GENERATED BY WORKFLOW-AGENT - DO NOT EDIT ABOVE THIS LINE -->";

interface WorkflowConfig {
  projectName?: string;
  scopes?: Array<{ name: string; description: string; emoji?: string }>;
  enforcement?: string;
  language?: string;
}

interface GuidelineSummary {
  filename: string;
  title: string;
  description: string;
  keyRules: string[];
}

/**
 * Extract title from markdown content (first H1)
 */
function extractTitle(content: string): string {
  const match = content.match(/^#\s+(.+)$/m);
  return match ? match[1].trim() : "Untitled";
}

/**
 * Extract description from markdown content (first paragraph after title)
 */
function extractDescription(content: string): string {
  // Look for content after the first heading, before the next heading or section
  const lines = content.split("\n");
  let foundTitle = false;
  let description = "";

  for (const line of lines) {
    if (line.startsWith("# ")) {
      foundTitle = true;
      continue;
    }
    if (foundTitle) {
      // Skip empty lines and blockquotes at start
      if (line.trim() === "" || line.startsWith(">")) {
        if (description) break; // End if we already have content
        continue;
      }
      // Stop at next heading or horizontal rule
      if (line.startsWith("#") || line.startsWith("---") || line.startsWith("##")) {
        break;
      }
      description += line.trim() + " ";
      // Take only first meaningful paragraph
      if (description.length > 150) break;
    }
  }

  return description.trim().slice(0, 200) + (description.length > 200 ? "..." : "");
}

/**
 * Rewrite markdown links to include ../guidelines/ prefix
 * Transforms links like [FILE.md](FILE.md) to [FILE.md](../guidelines/FILE.md)
 */
function rewriteGuidelineLinks(text: string): string {
  // Match markdown links: [text](file.md) where file.md is a .md file without path
  return text.replace(
    /\[([^\]]+)\]\(([A-Z_]+\.md)\)/g,
    (match, linkText, filename) => {
      // Only rewrite if it's just the filename (no path)
      if (!filename.includes("/")) {
        return `[${linkText}](../guidelines/${filename})`;
      }
      return match;
    }
  );
}

/**
 * Extract key rules from markdown content
 * Looks for lists, bold text, and important patterns
 */
function extractKeyRules(content: string, maxRules: number = 5): string[] {
  const rules: string[] = [];

  // Pattern 1: Look for "MUST", "NEVER", "ALWAYS", "REQUIRED" in bold or emphasized
  const emphasisPatterns = [
    /\*\*(?:MUST|NEVER|ALWAYS|REQUIRED)[^*]+\*\*/gi,
    /(?:^|\n)\s*[-*]\s+\*\*[^*]+\*\*/gm,
  ];

  for (const pattern of emphasisPatterns) {
    const matches = content.match(pattern);
    if (matches) {
      for (const match of matches.slice(0, 2)) {
        const cleaned = match.replace(/\*\*/g, "").replace(/^[-*]\s*/, "").trim();
        if (cleaned.length > 10 && cleaned.length < 150 && !rules.includes(cleaned)) {
          rules.push(cleaned);
        }
      }
    }
  }

  // Pattern 2: Look for numbered or bulleted rules under headings containing "Rules", "Requirements", "Guidelines"
  const rulesSectionMatch = content.match(/##\s+(?:.*(?:Rules?|Requirements?|Guidelines?|Standards?)[^\n]*)\n([\s\S]*?)(?=\n##|\n#|$)/i);
  if (rulesSectionMatch) {
    const section = rulesSectionMatch[1];
    const listItems = section.match(/^\s*[-*\d.]+\s+(.+)$/gm);
    if (listItems) {
      for (const item of listItems.slice(0, 3)) {
        const cleaned = item.replace(/^[-*\d.]+\s*/, "").trim();
        if (cleaned.length > 10 && cleaned.length < 150 && !rules.includes(cleaned)) {
          rules.push(cleaned);
        }
      }
    }
  }

  // Pattern 3: Look for key points under "Important", "Critical", "Key"
  const importantMatch = content.match(/(?:Important|Critical|Key|Essential)[:\s]+([^\n]+)/gi);
  if (importantMatch) {
    for (const match of importantMatch.slice(0, 2)) {
      const cleaned = match.replace(/^(?:Important|Critical|Key|Essential)[:\s]+/i, "").trim();
      if (cleaned.length > 10 && cleaned.length < 150 && !rules.includes(cleaned)) {
        rules.push(cleaned);
      }
    }
  }

  // Fallback: Get first few list items if we don't have enough rules
  if (rules.length < 2) {
    const listItems = content.match(/^\s*[-*]\s+(.+)$/gm);
    if (listItems) {
      for (const item of listItems.slice(0, 3)) {
        const cleaned = item.replace(/^[-*]\s*/, "").trim();
        if (cleaned.length > 15 && cleaned.length < 150 && !rules.includes(cleaned)) {
          rules.push(cleaned);
        }
      }
    }
  }

  return rules.slice(0, maxRules);
}

/**
 * Parse a guideline markdown file and extract summary
 */
function parseGuideline(filePath: string): GuidelineSummary | null {
  try {
    const content = readFileSync(filePath, "utf-8");
    const filename = basename(filePath);

    // Skip template example and non-guideline files
    if (filename.startsWith("_") || filename === "Guidelines.md") {
      return null;
    }

    return {
      filename,
      title: extractTitle(content),
      description: extractDescription(content),
      keyRules: extractKeyRules(content),
    };
  } catch {
    return null;
  }
}

/**
 * Load workflow config from project root
 */
function loadWorkflowConfig(projectRoot: string): WorkflowConfig | null {
  const configPath = join(projectRoot, "workflow.config.json");
  if (!existsSync(configPath)) {
    return null;
  }

  try {
    const content = readFileSync(configPath, "utf-8");
    return JSON.parse(content) as WorkflowConfig;
  } catch {
    return null;
  }
}

/**
 * Extract preserved custom content from existing file
 */
function extractCustomContent(existingContent: string): string | null {
  const startIndex = existingContent.indexOf(CUSTOM_START_MARKER);
  const endIndex = existingContent.indexOf(CUSTOM_END_MARKER);

  if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
    return existingContent.slice(
      startIndex + CUSTOM_START_MARKER.length,
      endIndex
    ).trim();
  }

  return null;
}

/**
 * Generate the copilot-instructions.md content
 */
function generateInstructionsContent(
  config: WorkflowConfig | null,
  guidelines: GuidelineSummary[],
  customContent: string | null
): string {
  const projectName = config?.projectName || "this project";
  const scopes = config?.scopes || [];

  let content = `# Copilot Instructions for ${projectName}

> **This file is the Single Source of Truth for AI agents working on this codebase.**
> It is auto-generated from the \`guidelines/\` directory by workflow-agent-cli.
> Last generated: ${new Date().toISOString().split("T")[0]}

${GENERATED_MARKER}

## Project Overview

`;

  if (config) {
    content += `- **Project Name**: ${projectName}\n`;
    content += `- **Enforcement Level**: ${config.enforcement || "strict"}\n`;
    if (scopes.length > 0) {
      content += `- **Available Scopes**: ${scopes.map(s => `\`${s.name}\``).join(", ")}\n`;
    }
    content += "\n";
  }

  // Add scope reference if available
  if (scopes.length > 0) {
    content += `### Valid Scopes for Commits and Branches

| Scope | Description |
|-------|-------------|
`;
    for (const scope of scopes.slice(0, 15)) {
      content += `| \`${scope.name}\` | ${scope.description} |\n`;
    }
    if (scopes.length > 15) {
      content += `| ... | See workflow.config.json for all ${scopes.length} scopes |\n`;
    }
    content += "\n";
  }

  // Add guidelines summaries
  if (guidelines.length > 0) {
    content += `## Guidelines Summary

The following guidelines govern development on this project. **Read the linked documents for full details.**

`;

    // Group by importance (mandatory templates first)
    const mandatoryFiles = [
      "AGENT_EDITING_INSTRUCTIONS.md",
      "BRANCHING_STRATEGY.md",
      "TESTING_STRATEGY.md",
      "SINGLE_SOURCE_OF_TRUTH.md",
      "PATTERN_ANALYSIS_WORKFLOW.md",
      "SELF_IMPROVEMENT_MANDATE.md",
    ];

    const sortedGuidelines = [...guidelines].sort((a, b) => {
      const aIndex = mandatoryFiles.indexOf(a.filename);
      const bIndex = mandatoryFiles.indexOf(b.filename);
      if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
      if (aIndex !== -1) return -1;
      if (bIndex !== -1) return 1;
      return a.title.localeCompare(b.title);
    });

    for (const guideline of sortedGuidelines) {
      content += `### ${guideline.title}

ðŸ“„ [See full details](../guidelines/${guideline.filename})

${guideline.description}

`;
      if (guideline.keyRules.length > 0) {
        content += `**Key Rules:**
`;
        for (const rule of guideline.keyRules) {
          // Rewrite any markdown links to include ../guidelines/ prefix
          content += `- ${rewriteGuidelineLinks(rule)}\n`;
        }
        content += "\n";
      }
    }
  }

  // Add quick reference section
  content += `## Quick Reference

### Branch Naming Convention
\`\`\`
<type>/<scope>/<short-description>
\`\`\`

**Types**: \`feature\`, \`fix\`, \`chore\`, \`docs\`, \`refactor\`, \`test\`, \`perf\`

### Commit Message Format
\`\`\`
<type>(<scope>): <description>

[optional body]

[optional footer]
\`\`\`

### Before Making Changes
1. Read the relevant guideline document in \`guidelines/\`
2. Check for existing patterns in \`workflow:solution:search\`
3. Create an implementation plan for multi-file changes
4. Ensure tests are added for new functionality

### Before Committing
1. Run \`pnpm run workflow:verify\` to validate all changes
2. Ensure branch name follows convention
3. Ensure commit message follows conventional commits format

`;

  // Add custom content section
  content += `## Project-Specific Instructions

${CUSTOM_START_MARKER}
${customContent || `
<!-- 
Add your project-specific instructions here.
This section will be preserved when the file is regenerated.

Examples:
- Specific coding patterns unique to this project
- Custom review requirements
- Domain-specific terminology
- Team-specific workflows
-->
`}
${CUSTOM_END_MARKER}

---

*This file was generated by [workflow-agent-cli](https://www.npmjs.com/package/workflow-agent-cli). Run \`pnpm run workflow:generate-instructions\` to regenerate.*
`;

  return content;
}

/**
 * Result of generating copilot instructions
 */
export interface GenerateResult {
  success: boolean;
  filePath: string | null;
  guidelinesCount: number;
  isNew: boolean;
  preservedCustomContent: boolean;
  error?: string;
}

/**
 * Generate .github/copilot-instructions.md from guidelines directory
 *
 * @param projectRoot - Root directory of the project
 * @param options - Generation options
 * @returns Result of the generation
 */
export function generateCopilotInstructions(
  projectRoot: string,
  options: { force?: boolean; silent?: boolean } = {}
): GenerateResult {
  const { force: _force = false, silent = false } = options;

  const guidelinesDir = join(projectRoot, "guidelines");
  const githubDir = join(projectRoot, ".github");
  const outputPath = join(githubDir, "copilot-instructions.md");

  // Check if guidelines directory exists
  if (!existsSync(guidelinesDir)) {
    if (!silent) {
      // Guidelines don't exist yet - skip silently during postinstall
    }
    return {
      success: false,
      filePath: null,
      guidelinesCount: 0,
      isNew: false,
      preservedCustomContent: false,
      error: "No guidelines directory found. Run 'workflow init' first.",
    };
  }

  // Read all markdown files from guidelines
  const files = readdirSync(guidelinesDir).filter(f => f.endsWith(".md"));
  if (files.length === 0) {
    return {
      success: false,
      filePath: null,
      guidelinesCount: 0,
      isNew: false,
      preservedCustomContent: false,
      error: "No markdown files found in guidelines directory.",
    };
  }

  // Parse each guideline
  const guidelines: GuidelineSummary[] = [];
  for (const file of files) {
    const summary = parseGuideline(join(guidelinesDir, file));
    if (summary) {
      guidelines.push(summary);
    }
  }

  // Load workflow config
  const config = loadWorkflowConfig(projectRoot);

  // Check for existing file and extract custom content
  let customContent: string | null = null;
  let isNew = true;

  if (existsSync(outputPath)) {
    isNew = false;
    const existingContent = readFileSync(outputPath, "utf-8");
    customContent = extractCustomContent(existingContent);
  }

  // Generate the content
  const content = generateInstructionsContent(config, guidelines, customContent);

  // Ensure .github directory exists
  if (!existsSync(githubDir)) {
    mkdirSync(githubDir, { recursive: true });
  }

  // Write the file
  writeFileSync(outputPath, content, "utf-8");

  return {
    success: true,
    filePath: outputPath,
    guidelinesCount: guidelines.length,
    isNew,
    preservedCustomContent: customContent !== null,
  };
}

/**
 * Check if copilot instructions need regeneration
 * (e.g., guidelines have been modified since last generation)
 */
export function needsRegeneration(projectRoot: string): boolean {
  const guidelinesDir = join(projectRoot, "guidelines");
  const outputPath = join(projectRoot, ".github", "copilot-instructions.md");

  if (!existsSync(outputPath)) {
    return existsSync(guidelinesDir);
  }

  // For now, always regenerate to ensure latest content
  // Future: could compare file modification times
  return true;
}
